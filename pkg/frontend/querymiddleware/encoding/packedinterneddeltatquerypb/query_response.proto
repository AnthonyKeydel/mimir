// SPDX-License-Identifier: AGPL-3.0-only

syntax = "proto3";

package packedinterneddeltatquerypb;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;

// HACK
// I've thrown this definition together without thinking too deeply about it.
// Things we'd need to consider, but I haven't thought through:
// - forwards compatibility considerations if we ever need to add or change this
// - any protobuf gotchas (I haven't used protobuf for a few years)

message QueryResponse {
  string Status = 1; // TODO: could this be an enum rather than a string?
  string ErrorType = 2; // TODO: could this be an enum rather than a string?
  string Error = 3;

  oneof Data {
    VectorData Vector = 4;
    ScalarData Scalar = 5;
    MatrixData Matrix = 6;

    // TODO: if we want to use this for all query types, we'd need to add support for string values
  }
}

message VectorData {
  repeated string Symbols = 1;
  int64 Timestamp = 2;

  // Why not use a repeated Sample type here? Repeated scalar types can be "packed" encoded, which is
  // both smaller in encoded form and more efficient to decode (as the length is known upfront).
  // See https://protobuf.dev/programming-guides/encoding/#packed.
  // Each metric in Metrics has the corresponding value in Values for the corresponding timestamp in Timestamps.
  //
  // TODO: will this make it more difficult to support native histograms?
  // (particularly for cases where some points have values and others are histograms)
  repeated Metric Metrics = 3 [(gogoproto.nullable) = false];
  repeated double Values = 4 [packed = true];
}

message Metric {
  repeated uint64 MetricSymbols = 1 [packed = true];
}

message ScalarData {
  double Value = 1;

  // TODO: is there a better type to use here?
  int64 Timestamp = 2; // milliseconds
}

message MatrixData {
  repeated string Symbols = 1;
  int64 BaseTimestamp = 2;
  repeated MatrixSeries Series = 3 [(gogoproto.nullable) = false];
}

message MatrixSeries {
  // Why not use a map<...> here? We want to preserve the order of the labels.
  // TODO: replace with Metric?
  repeated uint64 MetricSymbols = 1 [packed = true];

  // Why not use a repeated Sample type here? Repeated scalar types can be "packed" encoded, which is
  // both smaller in encoded form and more efficient to decode (as the length is known upfront).
  // See https://protobuf.dev/programming-guides/encoding/#packed.
  // Each value in Values is for the corresponding timestamp in Timestamps.
  //
  // TODO: will this make it more difficult to support native histograms?
  // (particularly for cases where some points have values and others are histograms)
  repeated double Values = 2 [packed = true];

  // First value: timestamp delta relative to MatrixData.BaseTimestamp.
  // Subsequent values: delta-of-deltas
  repeated int64 TimestampDeltas = 3 [packed = true];
}
